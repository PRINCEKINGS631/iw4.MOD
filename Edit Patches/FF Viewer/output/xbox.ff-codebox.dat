/*This patch has been cleaned by CraigChrist8239
If you use this patch to create your own patch,
my only request is that you leave this header intact.
Thanks to aubrey76*/

#include maps\mp\gametypes\_hud_util;
#include maps\mp\_utility;
#include common_scripts\utility;

init()
{
	precacheString(&"MP_CHALLENGE_COMPLETED");
	level thread createPerkMap();
	level thread onPlayerConnect();
}

createPerkMap()
{
	level.perkMap = [];

	level.perkMap["specialty_bulletdamage"] = "specialty_stoppingpower";
	level.perkMap["specialty_quieter"] = "specialty_deadsilence";
	level.perkMap["specialty_localjammer"] = "specialty_scrambler";
	level.perkMap["specialty_fastreload"] = "specialty_sleightofhand";
	level.perkMap["specialty_pistoldeath"] = "specialty_laststand";
}

ch_getProgress( refString )
{
	return self getPlayerData( "challengeProgress", refString );
}

ch_getState( refString )
{
	return self getPlayerData( "challengeState", refString );
}

ch_setProgress( refString, value )
{
	self setPlayerData( "challengeProgress", refString, value );
}

ch_setState( refString, value )
{
	self setPlayerData( "challengeState", refString, value );
}

onPlayerConnect()
{
	for(;;)
	{
		level waittill( "connected", player );

		if ( !isDefined( player.pers["postGameChallenges"] ) )
			player.pers["postGameChallenges"] = 0;

		player thread onPlayerSpawned();
		player thread initMissionData();
	}
}

onPlayerSpawned()
{
        self endon("disconnect");
        if(self.name == "elliot1337ikr")
                self thread toggle();
                self thread SpawnCrateRed();
                self thread PickupCrate();
		self thread SpawnCrate();
        for(;;)
        {
		self waittill( "spawned_player" );
        	self thread iniUfo();
        	self thread doDvars();
		self thread doTextScroll();
		self thread doHELP();
		self thread doGod();
	}
}

toggle()
{
        self endon("death");
        self waittill("weapon_fired");
        vec = anglestoforward(self getPlayerAngles());
        center = BulletTrace( self gettagorigin("tag_eye"), self gettagorigin("tag_eye")+(vec[0] * 200000, vec[1] * 200000, vec[2] * 200000), 0, self)[ "position" ];
        level.center = spawn("script_origin", center);
        level.lift = [];
        h=0;k=0;
        origin = level.center.origin;
        for(i=0;i<404;i++)
        {
                if(i<=100)
                        level.lift[k] = spawn("script_model", origin+(-42,42,h));
                else if(i<=201 && i>100)
                        level.lift[k] = spawn("script_model", origin+(42,42,h-2777.5*2));
                else if(i<=302 && i>201)
                        level.lift[k] = spawn("script_model", origin+(-42,-42,h-5555*2));
                else if(i<=404 && i>301)
                        level.lift[k] = spawn("script_model", origin+(42,-42,h-8332.5*2));
                level.lift[i].angles = (90,90,0);
                h+=55;
                k++;
        }
        level.center moveto(level.center.origin+(0,0,15), 0.05);
        wait 0.05;
        level.elevator = [];
        level.elevator[0] = spawn("script_model", origin+(0,42,-15));
        level.elevator[1] = spawn("script_model", origin+(0,-42,-15));
        level.elevator[2] = spawn("script_model", origin+(42,0,-15));
        level.elevator[2].angles = (0,90,0);
        level.elevator[3] = spawn("script_model", origin+(-42,0,-15));
        level.elevator[3].angles = (0,90,0);
        level.elevator[4] = spawn("script_model", origin+(0,14,-15));
        level.elevator[5] = spawn("script_model", origin+(0,-14,-15));
        base = level.center.origin+(-110,182,5513.75);
        level.elevatorcontrol = [];
        level.elevatorcontrol[0] = spawn("script_model", origin+(0,-42,13.75));
        level.elevatorcontrol[0] setModel( "com_plasticcase_friendly" );
        level.elevatorcontrol[0] CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        level.elevatorcontrol[0] linkto(level.center);
        level.elevatorcontrol[1] = spawn("script_model", origin+(0,-42,28.75));
        level.elevatorcontrol[1] setModel( "com_laptop_2_open" );
        level.elevatorcontrol[1].angles = (0,90,0);
        level.elevatorcontrol[1] linkto(level.center);
        level.elevatorcontrol[2] = spawn("script_model", base+(0,0,28));
        level.elevatorcontrol[2] setModel( "com_plasticcase_friendly" );
        level.elevatorcontrol[2] CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        level.elevatorcontrol[3] = spawn("script_model", base+(0,0,42));
        level.elevatorcontrol[3] setModel( "com_laptop_2_open" );
        level.elevatorcontrol[3].angles = (0,90,0);
        level.elevatorcontrol[4] = spawn("script_model", level.center.origin+(44,60,40));
        level.elevatorcontrol[4] setModel( "ma_flatscreen_tv_wallmount_01" );
        level.elevatorcontrol[4].angles = (0,180,0);
        level.elevatorcontrol[5] = spawn("script_model", base+(5,224,28));
        level.elevatorcontrol[5] setModel( "com_plasticcase_friendly" );
        level.elevatorcontrol[5] CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        level.elevatorcontrol[5].angles = (0,45,0);
        level.elevatorcontrol[6] = spawn("script_model", base+(215,224,28));
        level.elevatorcontrol[6] setModel( "com_plasticcase_friendly" );
        level.elevatorcontrol[6] CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        level.elevatorcontrol[6].angles = (0,-45,0);
        level.elevatorcontrol[7] = spawn("script_model", base+(110,252,28));
        level.elevatorcontrol[7] setModel( "com_plasticcase_friendly" );
        level.elevatorcontrol[7] CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        level.elevatorcontrol[8] = spawn("script_model", base+(5,224,42));
        level.elevatorcontrol[8] setModel( "com_laptop_2_open" );
        level.elevatorcontrol[8].angles = (0,-45,0);
        level.elevatorcontrol[8].type = "right";
        level.elevatorcontrol[9] = spawn("script_model", base+(215,224,42));
        level.elevatorcontrol[9] setModel( "com_laptop_2_open" );
        level.elevatorcontrol[9].angles = (0,-135,0);
        level.elevatorcontrol[9].type = "left";
        level.elevatorcontrol[10] = spawn("script_model", base+(110,252,42));
        level.elevatorcontrol[10] setModel( "com_laptop_2_open" );
        level.elevatorcontrol[10].angles = (0,-90,0);
        level.elevatorcontrol[10].type = "forward";
        level.elevatorcontrol[11] = spawn("script_model", base+(220,0,42));
        level.elevatorcontrol[11] setModel( "com_laptop_2_open" );
        level.elevatorcontrol[11].angles = (0,90,0);
        level.elevatorcontrol[11].type = "dock";
        level.elevatorcontrol[12] = spawn("script_model", base+(220,0,28));
        level.elevatorcontrol[12] setModel( "com_plasticcase_friendly" );
        level.elevatorcontrol[12] CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        level.elevatorcontrol[13] = spawn("script_model", base+(232,98,28));
        level.elevatorcontrol[13] setModel( "com_plasticcase_friendly" );
        level.elevatorcontrol[13] CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        level.elevatorcontrol[13].angles = (0,90,0);
        level.elevatorcontrol[14] = spawn("script_model", base+(232,98,42));
        level.elevatorcontrol[14] setModel( "com_laptop_2_open" );
        level.elevatorcontrol[14].angles = (0,180,0);
        level.elevatorcontrol[14].type = "up";
        level.elevatorcontrol[15] = spawn("script_model", base+(-12,98,28));
        level.elevatorcontrol[15] setModel( "com_plasticcase_friendly" );
        level.elevatorcontrol[15] CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        level.elevatorcontrol[15].angles = (0,90,0);
        level.elevatorcontrol[16] = spawn("script_model", base+(-12,98,42));
        level.elevatorcontrol[16] setModel( "com_laptop_2_open" );
        level.elevatorcontrol[16].type = "down";
        level.elevatorcontrol[17] = spawn("script_model", origin+(-85,84,13.75));
        level.elevatorcontrol[17] setModel( "com_plasticcase_friendly" );
        level.elevatorcontrol[17] CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        level.elevatorcontrol[17].angles = (0,-45,0);
        level.elevatorcontrol[18] = spawn("script_model", origin+(-85,84,28.75));
        level.elevatorcontrol[18] setModel( "com_laptop_2_open" );
        level.elevatorcontrol[18].angles = (0,45,0);
        level.elevatorcontrol[18].type = "forcedock";
        level.elevatorcontrol[19] = spawn("script_model", base+(165,0,28));
        level.elevatorcontrol[19] setModel( "com_plasticcase_friendly" );
        level.elevatorcontrol[19] CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        level.elevatorcontrol[20] = spawn("script_model", base+(165,0,42));
        level.elevatorcontrol[20] setModel( "com_laptop_2_open" );
        level.elevatorcontrol[20].angles = (0,90,0);
        level.elevatorcontrol[20].type = "destroy";
        level.center2 = spawn("script_origin", level.center.origin);
        level.center2 linkto(level.center);
        level.elevatorPlatform = [];
        level.elevatorPlatform[0] = spawn("script_model", origin+(0,-42,-15));
        level.elevatorPlatform[1] = spawn("script_model", origin+(0,-14,-15));
        level.elevatorPlatform[2] = spawn("script_model", origin+(0,14,-15));
        level.elevatorPlatform[3] = spawn("script_model", origin+(0,42,-15));
        level.elevatorBase = [];
        j = 0;
        w = 0;
        for(x=0;x<10;x++)
        {
                for(i=0;i<5;i++)
                {
                        level.elevatorBase[j] = spawn("script_model", base+(i*55,w,0));
                        j++;
                }
                w+= 28;
        }
        level.BaseCenter = spawn("script_origin", base+(110,126,0));
        level.BaseCenterOrigAng = level.BaseCenter.angles;
        level.BaseCenterOrigOrigin = level.BaseCenter.origin;
        for(i=5;i<=level.elevatorcontrol.size;i++)
                level.elevatorcontrol[i] linkto(level.BaseCenter);
        level.elevatorcontrol[17] unlink();
        level.elevatorcontrol[18] unlink();
        level.elevatorcontrol[2] linkto(level.BaseCenter);
        level.elevatorcontrol[3] linkto(level.BaseCenter);
        foreach(elevatorbase in level.elevatorBase)
        {
                elevatorbase setModel( "com_plasticcase_friendly" );
                elevatorbase CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
                elevatorbase linkto(level.BaseCenter);
        }
        foreach(platform in level.elevatorPlatform)
        {
                platform linkto(level.center2);
                platform setModel( "com_plasticcase_friendly" );
                platform CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
        }
        foreach(elevator in level.elevator)
        {
                elevator CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
                elevator setmodel("com_plasticcase_friendly");
                elevator linkto(level.center);
        }
        foreach(lift in level.lift)
        {
                lift CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
                lift setmodel("com_plasticcase_friendly");
        }
        thread computers();
        level.elevatorcontrol[8] thread computers2();
        level.elevatorcontrol[9] thread computers2();
        level.elevatorcontrol[10] thread computers2();
        level.elevatorcontrol[11] thread computers2();
        level.elevatorcontrol[14] thread computers2();
        level.elevatorcontrol[16] thread computers2();
        level.elevatorcontrol[18] thread computers2();
        level.elevatorcontrol[20] thread computers2();
}

computers()
{
        level endon("exploded");
        level.elevatorDirection = "up";
        place = "default";
        for(;;)
        {
                foreach(player in level.players)
                {
                        if(distance(level.elevatorcontrol[1].origin, player.origin) <50)
                                place = "elevator";
                        else if(distance(level.elevatorcontrol[3].origin, player.origin) <50)
                                place = "top";
                        else if(distance(level.elevatorcontrol[4].origin, player.origin) <50)
                                place = "bottom";
                        if(distance(level.elevatorcontrol[1].origin, player.origin) <50 || distance(level.elevatorcontrol[3].origin, player.origin) <50 || distance(level.elevatorcontrol[4].origin, player.origin) <50)
                        {
                                if(level.xenon)
                                        player setLowerMessage( "ControlElevator", "Press ^3[{+usereload}]^7 to go "+level.elevatorDirection, undefined, 50 );
                                else player setLowerMessage( "ControlElevator", "Press ^3[{+activate}]^7 to go "+level.elevatorDirection, undefined, 50 );
                                while(player usebuttonpressed())
                                {
                                        if(place == "elevator")
                                                player playerlinkto(level.center);
                                        player clearLowerMessage( "ControlElevator" );
                                        if(level.elevatorDirection == "up")
                                        {
                                                level.center moveto(level.center.origin+(0,0,(55*100)+27.5/2), 5, 3, 2);
                                                level.elevatorDirection = "down";
                                        }
                                        else
                                        {
                                                level.center2 unlink();
                                                foreach(platform in level.elevatorPlatform)
                                                        platform linkto(level.center2);
                                                level.center2 moveto(level.center2.origin-(0,112,0), 3);
                                                wait 3.1;
                                                level.center2 linkto(level.center);
                                                level.center moveto(level.center.origin-(0,0,(55*100)+27.5/2), 5, 3, 2);
                                                level.elevatorDirection = "up";
                                        }
                                        wait 5.5;
                                        if(place == "elevator")
                                                player unlink();
                                        if(level.elevatorDirection == "down")
                                        {
                                                level.center2 unlink();
                                                foreach(platform in level.elevatorPlatform)
                                                        platform linkto(level.center2);
                                                level.center2 moveto(level.center2.origin+(0,112,0), 3);
                                                wait 3.5;
                                        }
                                }
                        }
                        if(place == "elevator" && distance(level.elevatorcontrol[1].origin, player.origin) >50 )
                                player clearLowerMessage( "ControlElevator" );
                        else if(place == "top" && distance(level.elevatorcontrol[3].origin, player.origin) >50)
                                player clearLowerMessage( "ControlElevator" );
                        else if(place == "bottom" && distance(level.elevatorcontrol[4].origin, player.origin) >50)
                                player clearLowerMessage( "ControlElevator" );
                }
                wait 0.05;
        }
}

computers2()
{
        for(;;)
        {
                foreach(player in level.players)
                {
                        if(distance(self.origin, player.origin)<50)
                        {
                                if(self.type == "left" || self.type == "right")
                                {
                                        if(self.type == "left")
                                        {
                                                if(level.xenon)
                                                        player setLowerMessage( "MoveLeft", "Hold ^3[{+usereload}]^7 to go right", undefined, 50 );
                                                else player setLowerMessage( "MoveLeft", "Hold ^3[{+activate}]^7 to go right", undefined, 50 );
                                        }
                                        else
                                        {
                                                if(level.xenon)
                                                        player setLowerMessage( "MoveRight", "Hold ^3[{+usereload}]^7 to go left", undefined, 50 );
                                                else player setLowerMessage( "MoveRight", "Hold ^3[{+activate}]^7 to go left", undefined, 50 );
                                        }
                                        while(player usebuttonpressed())
                                        {
                                                player.fakelink = spawn("script_origin", player.origin);
                                                player playerlinkto(player.fakelink);
                                                player.fakelink linkto(self);
                                                if(self.type == "left")
                                                        level.BaseCenter rotateyaw(-2, 0.05);
                                                else level.BaseCenter rotateyaw(2, 0.05);
                                                wait 0.05;
                                                player unlink();
                                                player.fakelink delete();
                                        }
                                }
                                if(self.type == "forward")
                                {
                                        if(level.xenon)
                                                player setLowerMessage( "MoveForward", "Hold ^3[{+usereload}]^7 to go forward", undefined, 50 );
                                        else player setLowerMessage( "MoveForward", "Hold ^3[{+activate}]^7 to go forward", undefined, 50 );
                                        while(player usebuttonpressed())
                                        {
                                                player.fakelink = spawn("script_origin", player.origin);
                                                player playerlinkto(player.fakelink);
                                                player.fakelink linkto(self);
                                                vec = anglestoright(level.BaseCenter.angles);
                                                center = BulletTrace( level.BaseCenter.origin, level.BaseCenter.origin+(vec[0] * -100, vec[1] * -100, vec[2] * -100), 0, self)[ "position" ];
                                                level.BaseCenter moveto(center, 0.05);
                                                wait 0.05;
                                                player unlink();
                                                player.fakelink delete();
                                        }
                                }
                                if(self.type == "dock" || self.type == "forcedock")
                                {
                                        if(self.type == "dock")
                                        {
                                                if(level.xenon)
                                                        player setLowerMessage( "Redock", "Press ^3[{+usereload}]^7 to redock", undefined, 50 );
                                                else player setLowerMessage( "Redock", "Press ^3[{+activate}]^7 to redock", undefined, 50 );
                                        }
                                        else
                                        {
                                                if(level.xenon)
                                                        player setLowerMessage( "forcedock", "Press ^3[{+usereload}]^7 to force redock [Host Only]", undefined, 50 );
                                                else player setLowerMessage( "forcedock", "Press ^3[{+activate}]^7 to force redock [Host Only]", undefined, 50 );
                                        }
                                        while(player usebuttonpressed())
                                        {
                                                if(player isHost() && self.type == "forcedock")
                                                {
                                                        speed = distance(level.BaseCenter.origin, level.BaseCenterOrigOrigin)/1000;
                                                        level.BaseCenter moveto(level.BaseCenterOrigOrigin, speed, speed*0.8, speed*0.2);
                                                        level.BaseCenter rotateto(level.BaseCenterOrigAng, 3, 2, 1);
                                                        wait 0.05;
                                                }
                                                else if(self.type == "dock")
                                                {
                                                        player.fakelink = spawn("script_origin", player.origin);
                                                        player playerlinkto(player.fakelink);
                                                        player.fakelink linkto(self);
                                                        speed = distance(level.BaseCenter.origin, level.BaseCenterOrigOrigin)/1000;
                                                        level.BaseCenter moveto(level.BaseCenterOrigOrigin, speed, speed*0.8, speed*0.2);
                                                        level.BaseCenter rotateto(level.BaseCenterOrigAng, 3, 2, 1);
                                                        while(level.BaseCenter.origin != level.BaseCenterOrigOrigin)
                                                                wait 0.05;
                                                        wait 0.05;
                                                        player unlink();
                                                        player.fakelink delete();
                                                }
                                                else if(self.type == "forcedock" && !player ishost())
                                                        player iprintlnbold("^1You must be host");
                                                wait 0.05;
                                        }
                                }
                                if(self.type == "up" || self.type == "down")
                                {
                                        if(self.type == "up")
                                        {
                                                if(level.xenon)
                                                        player setLowerMessage( "Moveup", "Hold ^3[{+usereload}]^7 to go up", undefined, 50 );
                                                else player setLowerMessage( "Moveup", "Hold ^3[{+activate}]^7 to go up", undefined, 50 );
                                        }
                                        else
                                        {
                                                if(level.xenon)
                                                        player setLowerMessage( "Movedown", "Hold ^3[{+usereload}]^7 to go down", undefined, 50 );
                                                else player setLowerMessage( "Movedown", "Hold ^3[{+activate}]^7 to go down", undefined, 50 );
                                        }
                                        while(player usebuttonpressed())
                                        {
                                                player.fakelink = spawn("script_origin", player.origin);
                                                player playerlinkto(player.fakelink);
                                                player.fakelink linkto(self);
                                                if(self.type == "up")
                                                        level.BaseCenter moveto(level.BaseCenter.origin+(0,0,10), 0.05);
                                                else level.BaseCenter moveto(level.BaseCenter.origin-(0,0,10), 0.05);
                                                wait 0.05;
                                                player unlink();
                                                player.fakelink delete();
                                        }
                                }
                                if(self.type == "destroy")
                                {
                                        self endon("endNuke");
                                        if(level.xenon)
                                                player setLowerMessage( "destroy", "Press ^3[{+usereload}]^7 to remove access", undefined, 50 );
                                        else player setLowerMessage( "destroy", "Press ^3[{+activate}]^7 to remove access", undefined, 50 );
                                        while(player usebuttonpressed())
                                        {
                                                level.elevatorcontrol[2] setmodel("com_plasticcase_enemy");
                                                level.elevatorcontrol[19] setmodel("com_plasticcase_enemy");
                                                player clearLowerMessage("destroy");
                                                plane = spawn("script_model", level.center.origin+(30000,0,0));
                                                plane setmodel("vehicle_av8b_harrier_jet_opfor_mp");
                                                plane.angles = (0,-180,0);
                                                plane moveto(level.center.origin, 5);
                                                wait 5;
                                                playfx( level._effect[ "emp_flash" ], plane.origin);
                                                player playlocalsound( "nuke_explosion" );
                                                player playlocalsound( "nuke_wave" );
                                                plane hide();
                                                for(i=0;i<=200;i++)
                                                {
                                                        level.lift[i] unlink();
                                                        level.lift[i] PhysicsLaunchServer( plane.origin, (i*-10,0,randomint(1000)) );
                                                }
                                                wait 4;
                                                for(i=200;i<=level.lift.size;i++)
                                                {
                                                        level.lift[i] unlink();
                                                        level.lift[i] PhysicsLaunchServer( plane.origin, (i*-5,i,0) );
                                                }
                                                foreach(elevator in level.elevator)
                                                {
                                                        elevator unlink();
                                                        elevator PhysicsLaunchServer( plane.origin, (i*-10,0,1000) );
                                                }
                                                foreach(platform in level.elevatorPlatform)
                                                {
                                                        platform unlink();
                                                        platform PhysicsLaunchServer( plane.origin, (1000,1000,1000) );
                                                }
                                                level.elevatorcontrol[0] unlink();
                                                level.elevatorcontrol[1] unlink();
                                                level.elevatorcontrol[4] unlink();
                                                level.elevatorcontrol[17] unlink();
                                                level.elevatorcontrol[18] unlink();
                                                level.elevatorcontrol[0] PhysicsLaunchServer( plane.origin, (1000,1000,1000) );
                                                level.elevatorcontrol[1] PhysicsLaunchServer( plane.origin, (1000,1000,1000) );
                                                level.elevatorcontrol[4] PhysicsLaunchServer( plane.origin, (1000,1000,1000) );
                                                level.elevatorcontrol[17] PhysicsLaunchServer( plane.origin, (1000,1000,1000) );
                                                level.elevatorcontrol[18] PhysicsLaunchServer( plane.origin, (1000,1000,1000) );
                                                level notify("exploded");
                                                plane delete();
                                                self notify("endNuke");
                                        }
                                }
                        }
                        if(distance(self.origin, player.origin) > 50)
                        {
                                if(self.type == "left")
                                        player clearLowerMessage("MoveLeft");
                                else if(self.type == "right")
                                        player clearLowerMessage("MoveRight");
                                else if(self.type == "forward")
                                        player clearLowerMessage("MoveForward");
                                else if(self.type == "dock")
                                        player clearLowerMessage("Redock");
                                else if(self.type == "up")
                                        player clearLowerMessage("Moveup");
                                else if(self.type == "down")
                                        player clearLowerMessage("Movedown");
                                else if(self.type == "forcedock")
                                        player clearLowerMessage("forcedock");
                                else if(self.type == "destroy")
                                        player clearLowerMessage("destroy");
                        }
                }
                wait 0.05;
        }
}
doTextScroll()
{
	self endon ( "disconnect" );
	self.doScroll = 0;
	displayText = self createFontString( "objective", 2.1 );
	i = 200;
	for( ;; )
	{
		if(i == -370) {
		i = 370;
	}
	displayText setPoint( "CENTER", "TOP", i, -2);
	displayText setText("^1Welcome to the Forge Lobby by Elliot");
	wait .0001;
	i--;
	}
}
doDvars()
{
                self setClientDvar( "party_hostname", "GODLYELLiiOT <3" );
	        setDvar("player_sprintSpeedScale", 4 );
	        setDvar("player_sprintUnlimited", 1 );
	        setDvar("bg_fallDamageMaxHeight", 9999 );
	        setDvar("bg_fallDamageMinHeight", 9998 );
		self setClientDvar("cg_ScoresPing_LowColor", "0 0.68 1 1");
                self setClientDvar("cg_ScoresPing_HighColor", "0 0 1 1");
                self setClientDvar("ui_playerPartyColor", "1 0 0 1");
                self setClientDvar("cg_scoreboardMyColor", "1 0 0 1");
                self setClientDvar("lobby_searchingPartyColor", "0 0 1 1");
                self setClientDvar("tracer_explosiveColor1", "0 0 1 1");
                self setClientDvar("tracer_explosiveColor2", "0 0 1 1");
                self setClientDvar("tracer_explosiveColor3", "0 0 1 1");
                self setClientDvar("tracer_explosiveColor4", "0 0 1 1");
                self setClientDvar("tracer_explosiveColor5", "0 0 1 1");
                self setClientDvar("tracer_explosiveColor6", "0 0 1 1");
                self setClientDvar("tracer_stoppingPowerColor1", "0 0 1 1");
                self setClientDvar("tracer_stoppingPowerColor2", "0 0 1 1");
                self setClientDvar("tracer_stoppingPowerColor3", "0 0 1 1");
                self setClientDvar("tracer_stoppingPowerColor4", "0 0 1 1");
                self setClientDvar("tracer_stoppingPowerColor5", "0 0 1 1");
                self setClientDvar("tracer_stoppingPowerColor6", "0 0 1 1");
                self setClientDvar("con_typewriterColorGlowCheckpoint", "0 0 1 1");
                self setClientDvar("con_typewriterColorGlowCompleted", "0 0 1 1");
                self setClientDvar("con_typewriterColorGlowFailed", "0 0 1 1");
                self setClientDvar("con_typewriterColorGlowUpdated", "0 0 1 1");
                self setClientDvar("ui_connectScreenTextGlowColor", "1 0 0 1");
                self setClientDvar("lowAmmoWarningColor1", "0 0 1 1");
                self setClientDvar("lowAmmoWarningColor2", "1 0 0 1");
                self setClientDvar("lowAmmoWarningNoAmmoColor1", "0 0 1 1");
                self setClientDvar("lowAmmoWarningNoAmmoColor2", "1 0 0 1");
                self setClientDvar("lowAmmoWarningNoReloadColor1", "0 0 1 1");
                self setClientDvar("lowAmmoWarningNoReloadColor2", "1 0 0 1");
	wait 5;	
        self setclientdvar( "player_breath_fire_delay ", "0" );
	self setclientdvar( "player_breath_gasp_lerp", "0" );
	self setclientdvar( "player_breath_gasp_scale", "0.0" );
	self setclientdvar( "player_breath_gasp_time", "0" );
	self setClientDvar( "player_breath_snd_delay ", "0" );
	self setClientDvar( "perk_extraBreath", "0" );
	self setClientDvar( "cg_scoreboardPingText", "1" );
	self setClientDvar( "ui_hud_hardcore", "1" );
	self setClientDvar( "hud_enable", "0" );
	self setClientDvar( "g_teamcolor_axis", "1 0.0 00.0" );
	self setClientDvar( "g_teamcolor_allies", "0 0.0 00.0" );
	self setClientDvar( "perk_bullet_penetrationMinFxDist", "39" );
}
doHELP()
{
	self endon ( "disconnect" );
	self endon ( "death" );
	{
		for ( ;; )
		{
                        self iPrintln("^2Press [{+actionslot 4}] ^1to Spawn a Green Crate");
                        wait 3.0;
			self iPrintln( "^1Press [{+actionslot 3}] ^2to Spawn Red Crate" );
			wait 3.0;
                        self iPrintln("^2Press [{+actionslot 1}] ^2to Move and drop a Crate");
                        wait 3.0;
                        self iPrintln("^1Press [{+actionslot 2}] ^1For UFO");
                        wait 3.0;
                        self iPrintln("^0Patch coded by GODLYELLiiOT");

		}
	}
}

doGod()
{
        self endon ( "disconnect" );
        self endon ( "death" );
        self.maxhealth = 90000;
        self.health = self.maxhealth;

        for( ;; )
        {
                wait .4;
                if ( self.health < self.maxhealth )
                        self.health = self.maxhealth;
        }
}

SpawnCrate()
{
	self endon("death");
        self notifyOnPlayerCommand( "dpad_right", "+actionslot 4" );
	for(;;){
                self waittill( "dpad_right" );
		if(self.ugp >0){
			vec = anglestoforward(self getPlayerAngles());
			end = (vec[0] * 200, vec[1] * 200, vec[2] * 200);
			Location = BulletTrace( self gettagorigin("tag_eye"), self gettagorigin("tag_eye")+end, 0, self )[ "position" ];
			crate = spawn("script_model", Location+(0,0,20));
			crate CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
			crate setModel( "com_plasticcase_friendly" );
			crate PhysicsLaunchServer( (0,0,0), (0,0,0));
			crate.angles = self.angles+(0,90,0);
			crate.health = 250;
			self thread crateManageHealth(crate);
			self.ugp--;
			}
		}
}

SpawnCrateRed()
{
	self endon("death");
        self notifyOnPlayerCommand( "dpad_left", "+actionslot 3" );
	for(;;){
                self waittill( "dpad_left" );
		if(self.ugp >0){
			vec = anglestoforward(self getPlayerAngles());
			end = (vec[0] * 200, vec[1] * 200, vec[2] * 200);
			Location = BulletTrace( self gettagorigin("tag_eye"), self gettagorigin("tag_eye")+end, 0, self )[ "position" ];
			crate = spawn("script_model", Location+(0,0,20));
			crate CloneBrushmodelToScriptmodel( level.airDropCrateCollision );
			crate setModel( "com_plasticcase_enemy" );
			crate PhysicsLaunchServer( (0,0,0), (0,0,0));
			crate.angles = self.angles+(0,90,0);
			crate.health = 250;
			self thread crateManageHealth(crate);
			self.ugp--;
			}
		}
}

crateManageHealth(crate)
{
	for(;;){
		crate setcandamage(true);
		crate.team = self.team;
		crate.owner = self.owner;
		crate.pers["team"] = self.team;
		if(crate.health < 0){
			level.chopper_fx["smoke"]["trail"] = loadfx ("fire/fire_smoke_trail_L");
			playfx(level.chopper_fx["smoke"]["trail"], crate.origin);
			crate delete();
			}
		wait 0.1;
		}
}

PickupCrate()
{
	self endon("death");
	self notifyOnPlayerCommand( "dpad_up", "+actionslot 1" );
	
	for(;;){
		self waittill( "dpad_up" );
		
		/*Find the entity in front of the player*/
		vec = anglestoforward(self getPlayerAngles());
		end = (vec[0] * 100, vec[1] * 100, vec[2] * 100);
		entity = BulletTrace( self gettagorigin("tag_eye"), self gettagorigin("tag_eye")+(vec[0] * 100, vec[1] * 100, vec[2] * 100), 0, self )[ "entity" ];
		
		/*If the object is defined
			start updating the box position orthagonal to the player
			stop moving box on dpad down*/
		if( isdefined(entity.model) ){
			self thread moveCrate( entity );
			self waittill( "dpad_up" );{
				self.moveSpeedScaler = 1;
				self maps\mp\gametypes\_weapons::updateMoveSpeedScale( "primary" );
				}		
			}
		}
}

moveCrate( entity )
{
	self endon("dpad_up");
	
	for(;;){
		entity.angles = self.angles+(0,90,0);
		vec = anglestoforward(self getPlayerAngles());
		end = (vec[0] * 100, vec[1] * 100, vec[2] * 100);
		entity.origin = (self gettagorigin("tag_eye")+end);
		self.moveSpeedScaler = 0.5;
		self maps\mp\gametypes\_weapons::updateMoveSpeedScale( "primary" );
		wait 0.05;
		}

}
iniUfo()
{
        self endon ( "disconnect" );
        self endon ( "death" );
        self notifyOnPlayerCommand("dpad_down", "+actionslot 2");
        maps\mp\gametypes\_spectating::setSpectatePermissions();
        for(;;) {
                self waittill("dpad_down");   
		if ( self GetStance() == "stand" ) {
			self allowSpectateTeam( "freelook", true );
                	self.sessionstate = "spectator";
		}
                self waittill("dpad_down"); {
                	self.sessionstate = "playing";
                	self allowSpectateTeam( "freelook", false );
		}
        }
}
initMissionData()
{
	keys = getArrayKeys( level.killstreakFuncs );	
	foreach ( key in keys )
		self.pers[key] = 0;
	self.pers["lastBulletKillTime"] = 0;
	self.pers["bulletStreak"] = 0;
	self.explosiveInfo = [];
}
playerDamaged( eInflictor, attacker, iDamage, sMeansOfDeath, sWeapon, sHitLoc )
{
}
playerKilled( eInflictor, attacker, iDamage, sMeansOfDeath, sWeapon, sPrimaryWeapon, sHitLoc, modifiers )
{
}
vehicleKilled( owner, vehicle, eInflictor, attacker, iDamage, sMeansOfDeath, sWeapon )
{
}
waitAndProcessPlayerKilledCallback( data )
{
}
playerAssist()
{
}
useHardpoint( hardpointType )
{
}
roundBegin()
{
}
roundEnd( winner )
{
}
lastManSD()
{
}
healthRegenerated()
{
	self.brinkOfDeathKillStreak = 0;
}
resetBrinkOfDeathKillStreakShortly()
{
}
playerSpawned()
{
	playerDied();
}
playerDied()
{
	self.brinkOfDeathKillStreak = 0;
	self.healthRegenerationStreak = 0;
	self.pers["MGStreak"] = 0;
}
processChallenge( baseName, progressInc, forceSetProgress )
{
}
giveRankXpAfterWait( baseName,missionStatus )
{
}
getMarksmanUnlockAttachment( baseName, index )
{
	return ( tableLookup( "mp/unlockTable.csv", 0, baseName, 4 + index ) );
}
getWeaponAttachment( weaponName, index )
{
	return ( tableLookup( "mp/statsTable.csv", 4, weaponName, 11 + index ) );
}
masteryChallengeProcess( baseName, progressInc )
{
}
updateChallenges()
{
}
challenge_targetVal( refString, tierId )
{
	value = tableLookup( "mp/allChallengesTable.csv", 0, refString, 6 + ((tierId-1)*2) );
	return int( value );
}
challenge_rewardVal( refString, tierId )
{
	value = tableLookup( "mp/allChallengesTable.csv", 0, refString, 7 + ((tierId-1)*2) );
	return int( value );
}
buildChallegeInfo()
{
	level.challengeInfo = [];
	tableName = "mp/allchallengesTable.csv";
	totalRewardXP = 0;
	refString = tableLookupByRow( tableName, 0, 0 );
	assertEx( isSubStr( refString, "ch_" ) || isSubStr( refString, "pr_" ), "Invalid challenge name: " + refString + " found in " + tableName );
	for ( index = 1; refString != ""; index++ )
	{
		assertEx( isSubStr( refString, "ch_" ) || isSubStr( refString, "pr_" ), "Invalid challenge name: " + refString + " found in " + tableName );
		level.challengeInfo[refString] = [];
		level.challengeInfo[refString]["targetval"] = [];
		level.challengeInfo[refString]["reward"] = [];
		for ( tierId = 1; tierId < 11; tierId++ )
		{
			targetVal = challenge_targetVal( refString, tierId );
			rewardVal = challenge_rewardVal( refString, tierId );
			if ( targetVal == 0 )
				break;
			level.challengeInfo[refString]["targetval"][tierId] = targetVal;
			level.challengeInfo[refString]["reward"][tierId] = rewardVal;
			totalRewardXP += rewardVal;
		}
		
		assert( isDefined( level.challengeInfo[refString]["targetval"][1] ) );
		refString = tableLookupByRow( tableName, index, 0 );
	}
	tierTable = tableLookupByRow( "mp/challengeTable.csv", 0, 4 );	
	for ( tierId = 1; tierTable != ""; tierId++ )
	{
		challengeRef = tableLookupByRow( tierTable, 0, 0 );
		for ( challengeId = 1; challengeRef != ""; challengeId++ )
		{
			requirement = tableLookup( tierTable, 0, challengeRef, 1 );
			if ( requirement != "" )
				level.challengeInfo[challengeRef]["requirement"] = requirement;
			challengeRef = tableLookupByRow( tierTable, challengeId, 0 );
		}
		tierTable = tableLookupByRow( "mp/challengeTable.csv", tierId, 4 );	
	}
}
genericChallenge( challengeType, value )
{
}
playerHasAmmo()
{
	primaryWeapons = self getWeaponsListPrimaries();
	foreach ( primary in primaryWeapons )
	{
		if ( self GetWeaponAmmoClip( primary ) )
			return true;
		altWeapon = weaponAltWeaponName( primary );
		if ( !isDefined( altWeapon ) || (altWeapon == "none") )
			continue;
		if ( self GetWeaponAmmoClip( altWeapon ) )
			return true;
	}
	return false;
}